/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./dist/assets.js":
/*!************************!*\
  !*** ./dist/assets.js ***!
  \************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SnakeCurvePoint = exports.TextPortion = exports.GradientCircle = exports.BorderedCircle = exports.Circle = exports.SnakeVisualisation = exports.TextVisualisation = exports.VisualisationController = void 0;\n/**\n * Class: VisualisationController\n * Contains references to the two canvases and contexts for single-point-of-truth handling,\n * Keeps code DRY.\n */\nclass VisualisationController {\n    constructor(debug) {\n        // Main\n        this.isInside = false;\n        this.circles = [];\n        this.textPortions = [];\n        // Events and timings\n        this.manualSnakeReset = true;\n        this.circleLifetime = 1000;\n        this.lastDrawPoint = new SnakeCurvePoint(0, 0);\n        this.lastMousePoint = new SnakeCurvePoint(0, 0);\n        this.currentMousePoint = new SnakeCurvePoint(0, 0);\n        // Customisations\n        this.circleDrawMinGap = 30;\n        this.circleDrawFill = true;\n        this.circleDrawFillResolution = 30;\n        this.maxPoints = 400; // Limits gradient circles drawing too many fills\n        // Main Properties\n        this.debug = true;\n        // Define Text\n        this.fontSizePx = 150;\n        this.textLines = [\n            // BUILDING\n            {\n                y: window.innerHeight * 0.33 - this.fontSizePx,\n                portions: [\n                    { xPerc: 0.033, text: \"W E\" },\n                    { xPerc: 0.27, text: \"G E T\" },\n                    { xPerc: 0.55, text: \"S T R\" },\n                ],\n            },\n            // BETTER\n            {\n                y: window.innerHeight * 0.33,\n                portions: [\n                    { xPerc: 0.44, text: \"O\" },\n                    { xPerc: 0.55, text: \"N G\" },\n                    { xPerc: 0.75, text: \"E R\" },\n                ],\n            },\n            // FUTURES\n            {\n                y: window.innerHeight * 0.33 + this.fontSizePx,\n                portions: [\n                    { xPerc: 0.22, text: \"D A\" },\n                    { xPerc: 0.41, text: \"I L\" },\n                    { xPerc: 0.56, text: \"Y\" },\n                ],\n            },\n        ];\n        // Styles\n        this.currentCircleStyle = 0;\n        this.circleStyle = BorderedCircle;\n        this.fontSize = 150;\n        this.fontStyle = `${this.fontSize}px \"Open Sans Condensed\"`;\n        this.textFillStyleClipOutside = \"rgba(241, 77, 99, 1)\";\n        this.textFillStyleSnakeOutside = \"rgba(255, 255, 255, 1)\";\n        this.textFillStyleClipInside = \"rgba(241, 77, 99, 1)\";\n        this.textFillStyleSnakeInside = \"rgba(0, 0, 0, 1)\";\n        if (debug)\n            this.performanceTester = new PerformanceTester(this);\n    }\n    start() {\n        this.setEventListeners();\n        this.setIsInside(false);\n        window.requestAnimationFrame(this.animationFrame.bind(this));\n    }\n    setIsInside(res) {\n        this.isInside = res;\n        if (this.isInside) {\n            this.circleStyle = BorderedCircle;\n            this.currentCircleStyle = 0;\n            this.circleDrawMinGap = 30;\n            this.circleDrawFill = true;\n            this.circleDrawFillResolution = 30;\n        }\n        else {\n            this.circleStyle = GradientCircle;\n            this.currentCircleStyle = 1;\n            this.circleDrawMinGap = 0;\n            this.circleDrawFill = true;\n            this.circleDrawFillResolution = 3;\n        }\n        this.circles = [];\n    }\n    registerSnake(canvas, ctx) {\n        this.canvasSnake = canvas;\n        this.ctxSnake = ctx;\n        let canvasPosition = this.canvasSnake.getBoundingClientRect();\n        this.canvasPagePositionSnake = new SnakeCurvePoint(canvasPosition.x, canvasPosition.y);\n    }\n    registerText(canvas, ctx) {\n        this.canvasText = canvas;\n        this.ctxText = ctx;\n        let canvasPosition = this.canvasText.getBoundingClientRect();\n        this.canvasPagePositionText = new SnakeCurvePoint(canvasPosition.x, canvasPosition.y);\n    }\n    prepareCanvas(canvas) {\n        let canvasWorking = canvas;\n        canvasWorking.width = document.body.clientWidth;\n        canvasWorking.height = document.body.clientHeight;\n        return canvasWorking;\n    }\n    prepareCanvasContext(canvas, drawMode) {\n        const ctx = canvas.getContext(\"2d\");\n        if (!ctx || !(ctx instanceof CanvasRenderingContext2D)) {\n            throw new Error(\"Failed to get 2D context Text\");\n        }\n        ctx.globalCompositeOperation = drawMode;\n        ctx.font = this.fontStyle;\n        return ctx;\n    }\n    ////////////////////////////////////\n    // Setup Event Listeners (consider replacing this with Angularised events)\n    setEventListeners() {\n        var _a;\n        let scope = this;\n        (_a = document.querySelector(\"#switch\")) === null || _a === void 0 ? void 0 : _a.addEventListener(\"click\", (event) => {\n            this.setIsInside(!this.isInside);\n        });\n        // Reset on mouse leave\n        document.body.addEventListener(\"mouseleave\", (event) => {\n            this.manualSnakeReset = true;\n        });\n        // Update draw on mouse move\n        document.body.addEventListener(\"mousemove\", (event) => {\n            // Calculate mouse point\n            const eventPoint = new SnakeCurvePoint(event.pageX, event.pageY); //.adjustForCanvas(this.canvasPagePositionSnake);\n            scope.lastMousePoint = scope.currentMousePoint;\n            scope.currentMousePoint = eventPoint;\n            let distanceSinceLastDraw = eventPoint.distanceToPoint(scope.lastDrawPoint);\n            // Reset for massive distances, or when leaving\n            if (distanceSinceLastDraw > 1000 || this.manualSnakeReset) {\n                distanceSinceLastDraw = 0;\n                scope.lastMousePoint = eventPoint;\n                this.manualSnakeReset = false;\n            }\n            // If we have exceeded the draw minimum gap\n            if (distanceSinceLastDraw >= scope.circleDrawMinGap) {\n                if (scope.circleDrawFill) {\n                    const distanceSinceLastMouse = scope.lastMousePoint.distanceToPoint(scope.currentMousePoint);\n                    const steps = distanceSinceLastMouse / scope.circleDrawFillResolution;\n                    if (steps >= 2) {\n                        for (let i = 0; i <= 1; i += 1 / steps) {\n                            let padPoint = scope.lastDrawPoint.pointBetween(scope.currentMousePoint, i);\n                            addCircle(this, padPoint);\n                        }\n                    }\n                    else {\n                        addCircle(this, eventPoint);\n                    }\n                }\n                else {\n                    addCircle(this, eventPoint);\n                }\n                scope.lastDrawPoint = eventPoint;\n            }\n            function addCircle(visualisation, point) {\n                new scope.circleStyle(visualisation, point);\n            }\n        });\n    }\n    // Animation Frame Event Fire\n    animationFrame() {\n        var _a;\n        // Performance Test\n        (_a = this.performanceTester) === null || _a === void 0 ? void 0 : _a.test();\n        // Main Canvas\n        this.snakeVisualisation.draw();\n        // Clipped Text Canvas\n        this.textVisualisation.draw();\n        window.requestAnimationFrame(this.animationFrame.bind(this));\n    }\n}\nexports.VisualisationController = VisualisationController;\n/**\n * Class: TextVisualisation\n */\nclass TextVisualisation {\n    constructor(vis, canvas) {\n        this.vis = vis;\n        vis.registerText(this.vis.prepareCanvas(canvas), this.vis.prepareCanvasContext(canvas, \"destination-over\"));\n        vis.textVisualisation = this;\n    }\n    draw() {\n        // Save the state\n        this.vis.ctxText.save();\n        // Setup clipping based on arcs\n        this.vis.ctxText.clearRect(0, 0, this.vis.canvasText.width, this.vis.canvasText.height);\n        this.vis.ctxText.beginPath();\n        let path = new Path2D();\n        this.vis.circles.forEach((circle) => {\n            circle.addClipPath(path);\n        });\n        this.vis.ctxText.clip(path);\n        // Draw text components\n        this.vis.ctxText.fillStyle = this.vis.isInside\n            ? this.vis.textFillStyleClipInside\n            : this.vis.textFillStyleClipOutside;\n        this.vis.textPortions.forEach((text) => text.draw(this.vis.ctxText));\n        // And finally, restore\n        this.vis.ctxText.restore();\n    }\n}\nexports.TextVisualisation = TextVisualisation;\n// CLASS: SnakeVisualisation\n// Controls the Snake rendering\nclass SnakeVisualisation {\n    ////////////////////////////////////\n    // CONSTRUCTOR\n    constructor(vis, canvas) {\n        this.vis = vis;\n        vis.registerSnake(this.vis.prepareCanvas(canvas), this.vis.prepareCanvasContext(canvas, \"destination-over\"));\n        vis.snakeVisualisation = this;\n    }\n    // Draw circles and text\n    draw() {\n        this.vis.ctxSnake.clearRect(0, 0, this.vis.canvasSnake.width, this.vis.canvasSnake.height);\n        this.vis.circles.forEach((circle) => {\n            circle.draw(this.vis.ctxSnake, this.vis);\n        });\n        // And draw text portions\n        this.vis.ctxSnake.fillStyle = this.vis.isInside\n            ? this.vis.textFillStyleSnakeInside\n            : this.vis.textFillStyleSnakeOutside;\n        this.vis.textPortions.forEach((text) => text.draw(this.vis.ctxSnake));\n    }\n}\nexports.SnakeVisualisation = SnakeVisualisation;\nclass PerformanceTester {\n    constructor(visualisationController) {\n        this.mouseMoves = {\n            0: 0,\n            1: 0,\n            2: 0,\n            3: 0,\n            4: 0,\n            5: 0,\n            6: 0,\n            7: 0,\n            8: 0,\n            9: 0,\n        };\n        this.lastTestSecond = 0;\n        this.shouldReset = false;\n        this.vis = visualisationController;\n    }\n    // Test and respond\n    test() {\n        let second = Math.floor(parseInt(new Date().getTime().toString().substr(-4)) / 1000);\n        this.mouseMoves[second] += 1;\n        if (second != this.lastTestSecond) {\n            console.log(`Perf ${this.mouseMoves[second - 1]} frames, ${this.vis.circles.length}`);\n            this.lastTestSecond = second;\n        }\n        if (second === 0 && this.shouldReset) {\n            this.reset();\n            this.shouldReset = false;\n        }\n        if (second >= 9) {\n            this.shouldReset = true;\n        }\n    }\n    // Reset every 10 seconds\n    reset() {\n        Object.keys(this.mouseMoves).forEach((key) => {\n            this.mouseMoves[key] = 0;\n        });\n    }\n}\n// Circle Class\nclass Circle {\n    constructor(visualisationCon, point) {\n        // Default properties\n        this.birth = 0;\n        this.x = 0;\n        this.y = 0;\n        this.distanceFromLastMouse = new SnakeCurvePoint(0, 0);\n        // Style properties\n        this.circleRadius = 75;\n        this.circleBorder = 10;\n        this.opacity = 1;\n        if (visualisationCon.currentMousePoint) {\n            this.birth = new Date().getTime();\n            this.x = point.x;\n            this.y = point.y;\n            this.distanceFromLastMouse = new SnakeCurvePoint(visualisationCon.currentMousePoint.x - visualisationCon.lastDrawPoint.x, visualisationCon.currentMousePoint.y - visualisationCon.lastDrawPoint.y);\n        }\n        // Set Opacity based on y pos (simple, just percentage of canvas)\n        let percentageStart = 0.8;\n        let percentageCutoff = 0.9;\n        let yPercentage = this.y / (visualisationCon.canvasText.height * percentageCutoff);\n        if (yPercentage > percentageStart) {\n            let remainder = 1 - percentageCutoff;\n            let innerPercentage = (yPercentage - percentageCutoff) / remainder;\n            this.opacity = 1 - innerPercentage;\n        }\n        visualisationCon.circles.unshift(this);\n        if (visualisationCon.circles.length > visualisationCon.maxPoints) {\n            visualisationCon.circles.pop();\n        }\n    }\n    draw(ctx, visualisationCon) { }\n    addClipPath(path) {\n        let clipPath = new Path2D();\n        clipPath.arc(this.x, this.y, this.circleRadius, 0, 2 * Math.PI, false);\n        path.addPath(clipPath);\n    }\n}\nexports.Circle = Circle;\nclass BorderedCircle extends Circle {\n    draw(ctx, visualisationCon) {\n        if (new Date().getTime() - this.birth < visualisationCon.circleLifetime) {\n            ctx.beginPath();\n            ctx.arc(this.x, this.y, this.circleRadius, 0, 2 * Math.PI, false);\n            ctx.fillStyle = `rgba(230, 230, 230, ${this.opacity})`;\n            ctx.fill();\n            ctx.lineWidth = 10;\n            ctx.strokeStyle = `rgba(241, 77, 99, ${this.opacity})`;\n            ctx.stroke();\n        }\n        else {\n            visualisationCon.circles = visualisationCon.circles.filter((storedCircle) => storedCircle != this);\n        }\n    }\n}\nexports.BorderedCircle = BorderedCircle;\nclass GradientCircle extends Circle {\n    constructor() {\n        super(...arguments);\n        this.opacityAdjust = -0.3;\n        this.gradientStop1 = `rgba(231, 29, 54, ${this.opacity + this.opacityAdjust})`;\n        this.gradientStop2 = `rgba(229, 255, 94, ${this.opacity + this.opacityAdjust})`;\n    }\n    draw(ctx, visualisationCon) {\n        if (new Date().getTime() - this.birth < visualisationCon.circleLifetime) {\n            ctx.beginPath();\n            ctx.arc(this.x, this.y, this.circleRadius, 0, 2 * Math.PI, false);\n            // Draw a gradient which spreads further than bounds, so that we can adjust the gradient stops\n            const radPart = this.circleRadius * 1.5;\n            var gradient = ctx.createLinearGradient(\n            /* x1 */ this.x - radPart, // Adjusted by speed mouse moving down\n            /* y1 */ this.y - radPart, \n            /* x2 */ this.x + radPart, // Adjusted by speed mouse moving down\n            /* y2 */ this.y + radPart);\n            // Adjust the gradient based on mouse speed and y direction\n            gradient.addColorStop(0.25, this.gradientStop1);\n            gradient.addColorStop(0.7, this.gradientStop2);\n            ctx.arc(this.x, this.y, this.circleRadius, 0, 2 * Math.PI, false);\n            ctx.fillStyle = gradient;\n            ctx.fill();\n        }\n        else {\n            visualisationCon.circles = visualisationCon.circles.filter((storedCircle) => storedCircle != this);\n        }\n    }\n}\nexports.GradientCircle = GradientCircle;\nclass TextPortion {\n    constructor(visualisationCon, text, point) {\n        this.text = \"\";\n        this.x = 0;\n        this.y = 0;\n        this.fontSize = 0;\n        this.font = \"\";\n        this.vis = visualisationCon;\n        this.text = text;\n        this.x = point.x;\n        this.y = point.y;\n        this.fontSize = visualisationCon.fontSize;\n    }\n    draw(ctx) {\n        ctx.fillText(this.text, this.x, this.y + this.vis.fontSize);\n    }\n}\nexports.TextPortion = TextPortion;\nclass SnakeCurvePoint {\n    constructor(x, y, expires) {\n        this.x = x;\n        this.y = y;\n        if (expires)\n            this.expires = expires;\n    }\n    get asArray() {\n        return [this.x, this.y];\n    }\n    get asObject() {\n        return { x: this.x, y: this.y };\n    }\n    fromArray(valuesArr) {\n        this.x = valuesArr[0];\n        this.y = valuesArr[1];\n        return this;\n    }\n    setValues(x, y) {\n        this.x = x;\n        this.y = y;\n        return this;\n    }\n    adjustForCanvas(canvasPosition) {\n        this.x = this.x - canvasPosition.x;\n        this.y = this.y - canvasPosition.y;\n        return this;\n    }\n    distanceToPoint(comparePoint) {\n        var a = this.x - comparePoint.x;\n        var b = this.y - comparePoint.y;\n        return Math.sqrt(a * a + b * b);\n    }\n    distanceToPointY(comparePoint) {\n        return this.y - comparePoint.y;\n    }\n    pointBetween(comparePoint, percent) {\n        return new SnakeCurvePoint(this.x + (comparePoint.x - this.x) * percent, this.y + (comparePoint.y - this.y) * percent);\n    }\n}\nexports.SnakeCurvePoint = SnakeCurvePoint;\n//# sourceMappingURL=assets.js.map\n\n//# sourceURL=webpack://wormy/./dist/assets.js?");

/***/ }),

/***/ "./dist/index.js":
/*!***********************!*\
  !*** ./dist/index.js ***!
  \***********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst assets_1 = __webpack_require__(/*! ./assets */ \"./dist/assets.js\");\nlet debug = true;\n// Using setTimeout is awful, but serves our rapid migration from Angular code to TSC and Webpack\nsetTimeout(() => {\n    let visualisationController = new assets_1.VisualisationController(debug);\n    new assets_1.TextVisualisation(visualisationController, document.querySelector(\"#canvasText\"));\n    new assets_1.SnakeVisualisation(visualisationController, document.querySelector(\"#canvasSnake\"));\n    visualisationController.start();\n    // Setup text\n    visualisationController.textLines.forEach((textLine) => {\n        let y = textLine.y;\n        textLine.portions.forEach((text) => {\n            let x = text.xPerc * visualisationController.canvasText.width;\n            let textPortion = new assets_1.TextPortion(visualisationController, text.text, new assets_1.SnakeCurvePoint(x, y));\n            visualisationController.textPortions.push(textPortion);\n        });\n    });\n}, 1000);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://wormy/./dist/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./dist/index.js");
/******/ 	
/******/ })()
;